use core::convert::AsRef;
use core::time::Duration;
use std::ops::{Deref, DerefMut};
use glium::backend::Facade;
use glium::draw_parameters::DrawParameters;
use glium::{Frame, Program, Surface};
use glium::texture::MipmapsOption;
use glium::uniforms::{MagnifySamplerFilter, MinifySamplerFilter};
use crate::traits::Drawable;
use crate::transformations::Transformation;
use crate::utils::Rect;
use crate::vertex::{Point, UVPoint};

#[derive(Debug)]
pub struct Texture {
    texture: glium::texture::SrgbTexture2d,
    orig_size: (u32, u32),
    width: f32,
    pos: (f32, f32),
    transformation: Transformation,
}


impl AsRef<glium::texture::SrgbTexture2d> for Texture {
    fn as_ref(&self) -> &glium::texture::SrgbTexture2d {
        &self.texture
    }
}

impl Deref for Texture {
    type Target = Transformation;

    fn deref(&self) -> &Self::Target {
        &self.transformation
    }
}

impl DerefMut for Texture {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.transformation
    }
}

impl Texture {
    pub fn new(
        path: &str,
        display: &dyn glium::backend::Facade,
        pos: (f32, f32),
        width: Option<f32>,
    ) -> Texture {
        let (texture, size) = load_texture(path, display);
        let mut self_texture = Texture {
            texture,
            orig_size: size,
            width: 0.,
            pos,
            transformation: Transformation::new(),
        };

        match width {
            Some(width) => self_texture.set_width(width),
            None => (),
        }

        self_texture.set_pos(pos);
        self_texture
    }

    pub fn set_width(&mut self, width: f32) {
        self.width = width;
        let scale_x = width / 2.;
        let scale_y = self.get_height() / 2.;

        self.scale = Some((scale_x, scale_y));
    }

    pub fn set_rotation(&mut self, rotation: f32) {
        self.rotation = Some(rotation);
    }

    pub fn set_pos(&mut self, pos: (f32, f32)) {
        self.pos = pos;
        self.transformation.translation = Some([
            pos.0 + self.width / 2.,
            pos.1 - self.get_height() / 2.,
        ]);
    }

    pub fn set_pos_center(&mut self, pos: (f32, f32)) {
        let height = self.get_height();
        let width = self.get_width();

        self.set_pos(
            (pos.0 - width / 2., pos.1 + height / 2.)
        )
    }

    pub fn get_height(&self) -> f32 {
        (self.orig_size.1 as f32) / (self.orig_size.0 as f32) * self.width
    }

    pub fn get_rect(&self) -> Rect {
        Rect {
            tl: self.pos,
            br: (self.pos.0 + self.width, self.pos.1 - self.get_height())
        }
    }

    pub fn get_width(&self) -> f32 {
        self.width
    }
}

impl Drawable for Texture {
    fn draw(&self, mut frame: Frame, facade: &dyn Facade, program: &Program) -> Frame {

        let vertices_buffer = Point::standard_rectangle_buffer(facade);
        let uvs_buffer = UVPoint::standard_rectangle_buffer(facade);
        let indices = glium::index::IndexBuffer::new(
            facade,
            glium::index::PrimitiveType::TrianglesList,
            &[0u16, 1, 2, 0, 2, 3],
        )
        .unwrap();

        let mut sampler = glium::uniforms::Sampler::new(&self.texture);
        sampler = sampler.minify_filter(MinifySamplerFilter::Linear);
        sampler = sampler.magnify_filter(MagnifySamplerFilter::Nearest);

        let uniform = glium::uniform! {
            tex: sampler,
            model: self.get_matrix().data.0,
        };

        let mut parameters = DrawParameters::default();
        parameters.blend = glium::Blend::alpha_blending();

        frame.draw(
            (&vertices_buffer, &uvs_buffer),
            &indices,
            program,
            &uniform,
            &parameters,
        );

        frame
    }

    fn update(&mut self, dt: Duration) {}
}

pub fn load_texture(
    path: &str,
    display: &dyn glium::backend::Facade,
) -> (glium::texture::SrgbTexture2d, (u32, u32)) {
    let image = image::load(
        std::io::BufReader::new(std::fs::File::open(path).unwrap()),
        image::ImageFormat::Png,
    )
    .unwrap()
    .to_rgba8();
    let image_dimensions = image.dimensions();
    let image =
        glium::texture::RawImage2d::from_raw_rgba_reversed(&image.into_raw(), image_dimensions);

    (
        glium::texture::SrgbTexture2d::with_format(
            display,
            image,
            glium::texture::SrgbFormat::U8U8U8U8,
            MipmapsOption::AutoGeneratedMipmaps,
        )
        .unwrap(),
        image_dimensions,
    )
}
